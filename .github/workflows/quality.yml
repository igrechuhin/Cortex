name: Code Quality

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

# Cancel redundant runs when new commits are pushed to the same branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    runs-on: ubuntu-latest
    # Ensure the job stops on first failure (default behavior, but explicit is better)
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Install uv
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"

      - name: Display environment info
        run: |
          echo "=== Environment Information ==="
          echo "Python version: $(python --version)"
          echo "uv version: $(uv --version)"
          echo "Working directory: $(pwd)"
          echo "Git commit: ${{ github.sha }}"
          echo "Git ref: ${{ github.ref }}"
          echo "==============================="

      - name: Install dependencies
        run: |
          uv sync --group dev --extra dev

      - name: Verify tool versions
        run: |
          echo "=== Tool Versions ==="
          uv run black --version
          uv run ruff --version
          uv run pyright --version
          uv run pytest --version
          echo "===================="

      - name: Check formatting (Black)
        id: formatting
        run: |
          echo "::group::Running Black formatting check"
          if ! uv run black --check src/ tests/; then
            echo "::error::Black formatting check failed. Run 'black src/ tests/' to fix."
            exit 1
          fi
          echo "✅ Black formatting check passed"
          echo "::endgroup::"

      - name: Lint with ruff (includes import sorting and unused imports)
        id: linting
        run: |
          echo "::group::Running Ruff linting check"
          # Ruff F401 catches unused imports, F841 catches unused variables
          # Run with strict checking to catch all issues
          # Note: .cortex/synapse/scripts/ is checked by the synapse scripts themselves
          if ! uv run ruff check --select F,E,W src/ tests/; then
            echo "::error::Ruff linting check failed. Run 'ruff check --fix src/ tests/' to fix auto-fixable issues."
            exit 1
          fi
          echo "✅ Ruff linting check passed"
          echo "::endgroup::"

      - name: Type check with pyright (source)
        id: type_check_src
        run: |
          echo "::group::Running Pyright type check (source)"
          # Try JSON output first for reliable parsing
          JSON_OUTPUT=$(uv run pyright --outputjson src/ 2>&1) || true
          TEXT_OUTPUT=$(uv run pyright src/ 2>&1) || true
          
          # Display text output for readability
          echo "$TEXT_OUTPUT"
          
          # Parse JSON output if available
          HAS_ERROR=false
          ERROR_COUNT=0
          WARNING_COUNT=0
          
          if echo "$JSON_OUTPUT" | python3 -m json.tool > /dev/null 2>&1; then
            # Parse JSON output
            ERROR_COUNT=$(echo "$JSON_OUTPUT" | python3 -c "import sys, json; data = json.load(sys.stdin); print(data.get('summary', {}).get('errorCount', 0))" 2>/dev/null || echo "0")
            WARNING_COUNT=$(echo "$JSON_OUTPUT" | python3 -c "import sys, json; data = json.load(sys.stdin); print(data.get('summary', {}).get('warningCount', 0))" 2>/dev/null || echo "0")
            
            # Check for specific error rules in diagnostics, including rules that
            # some engines might not surface as \"error\" severity
            ERROR_RULES=$(echo "$JSON_OUTPUT" | python3 -c "import sys, json; data = json.load(sys.stdin); diags = data.get('generalDiagnostics', []); important_rules = {'reportUnknownParameterType'}; rules = [d.get('rule', '') for d in diags if d.get('severity', '').lower() == 'error' or d.get('rule', '') in important_rules]; print(' '.join(sorted(set(filter(None, rules)))))" 2>/dev/null || echo \"\")
            
            if [ "$ERROR_COUNT" -gt 0 ] || [ "$WARNING_COUNT" -gt 0 ] || [ -n "$ERROR_RULES" ]; then
              HAS_ERROR=true
            fi
          else
            # Fallback to text parsing
            ERROR_PATTERNS=(
              "error:"
              "reportUnknownParameterType"
              "reportArgumentType"
              "reportUnknownVariableType"
              "reportUnknownMemberType"
              "reportAttributeAccessIssue"
              "reportAssignmentType"
              "reportIndexIssue"
              "reportOperatorIssue"
              "reportGeneralTypeIssues"
              "reportUnknownArgumentType"
              "reportOptionalSubscript"
              "reportCallIssue"
            )
            
            for pattern in "${ERROR_PATTERNS[@]}"; do
              if echo "$TEXT_OUTPUT" | grep -qi "$pattern"; then
                HAS_ERROR=true
                break
              fi
            done
            
            # Check error count in summary
            ERROR_COUNT=$(echo "$TEXT_OUTPUT" | grep -oE "[0-9]+\s+error" | grep -oE "[0-9]+" | head -1 || echo "0")
            WARNING_COUNT=$(echo "$TEXT_OUTPUT" | grep -oE "[0-9]+\s+warning" | grep -oE "[0-9]+" | head -1 || echo "0")
          fi
          
          if [ "$HAS_ERROR" = true ] || [ "$ERROR_COUNT" -gt 0 ] || [ "$WARNING_COUNT" -gt 0 ]; then
            echo "::error::Pyright type check failed with $ERROR_COUNT error(s) and $WARNING_COUNT warning(s)."
            exit 1
          fi
          
          echo "✅ Pyright type check passed (source)"
          echo "::endgroup::"

      - name: Check formatting (synapse scripts)
        id: formatting_synapse
        run: |
          echo "::group::Running Black formatting check (synapse scripts)"
          # Use synapse script which checks synapse scripts themselves
          if ! uv run python .cortex/synapse/scripts/python/check_formatting.py; then
            echo "::error::Formatting check failed for synapse scripts. Fix formatting errors before committing."
            exit 1
          fi
          echo "✅ Black formatting check passed (synapse scripts)"
          echo "::endgroup::"

      - name: Lint with ruff (synapse scripts)
        id: linting_synapse
        run: |
          echo "::group::Running Ruff linting check (synapse scripts)"
          # Use synapse script which checks synapse scripts themselves
          if ! uv run python .cortex/synapse/scripts/python/check_linting.py; then
            echo "::error::Linting check failed for synapse scripts. Fix linting errors before committing."
            exit 1
          fi
          echo "✅ Ruff linting check passed (synapse scripts)"
          echo "::endgroup::"

      - name: Type check with pyright (tests and scripts)
        id: type_check_tests
        run: |
          echo "::group::Running Pyright type check (tests and scripts)"
          # Use the check_types script which handles tests and scripts properly
          if ! uv run python .cortex/synapse/scripts/python/check_types.py; then
            echo "::error::Type check failed for tests or scripts. Fix type errors before committing."
            exit 1
          fi
          echo "✅ Pyright type check passed (tests and scripts)"
          echo "::endgroup::"

      - name: Check file sizes (max 400 lines)
        id: file_sizes
        run: |
          echo "::group::Running file size check"
          if ! uv run python .cortex/synapse/scripts/python/check_file_sizes.py; then
            echo "::error::File size check failed. Files exceeding 400 lines must be split."
            exit 1
          fi
          echo "::endgroup::"

      - name: Check function lengths (max 30 lines)
        id: function_lengths
        run: |
          echo "::group::Running function length check"
          if ! uv run python .cortex/synapse/scripts/python/check_function_lengths.py; then
            echo "::error::Function length check failed. Functions exceeding 30 lines must be refactored."
            exit 1
          fi
          echo "::endgroup::"

      - name: Check spelling (cSpell)
        id: spelling
        run: |
          echo "::group::Running spelling check"
          # Install cspell if not available
          if ! command -v cspell &> /dev/null; then
            npm install -g cspell
          fi
          
          # Run spelling check using the script
          if ! uv run python .cortex/synapse/scripts/python/check_spelling.py; then
            echo "::error::Spelling check failed. Fix spelling errors or add words to .cspell.json dictionary."
            exit 1
          fi
          echo "✅ Spelling check passed"
          echo "::endgroup::"
        continue-on-error: false

      - name: Check markdown files (markdownlint)
        id: markdown_lint
        run: |
          echo "::group::Running markdown lint check"
          # Install markdownlint-cli2 if not available
          if ! command -v markdownlint-cli2 &> /dev/null; then
            npm install -g markdownlint-cli2
          fi
          
          # Find all markdown files (excluding node_modules, archived plans, and other common excludes)
          MD_FILES=$(find . -name "*.md" -o -name "*.mdc" | grep -v node_modules | grep -v .venv | grep -v __pycache__ | grep -v ".git" | grep -v ".cortex/plans/archive" | head -500)
          
          if [ -n "$MD_FILES" ]; then
            # Run markdownlint with config if it exists
            # Prefer .markdownlint-cli2.yaml (supports ignore patterns) over .markdownlint.json
            if [ -f ".markdownlint-cli2.yaml" ]; then
              if ! echo "$MD_FILES" | xargs markdownlint-cli2 --config .markdownlint-cli2.yaml 2>&1; then
                echo "::error::Markdown lint issues detected. Run 'markdownlint-cli2 --fix' to fix auto-fixable issues."
                exit 1
              else
                echo "✅ Markdown lint check passed"
              fi
            elif [ -f ".markdownlint.json" ]; then
              if ! echo "$MD_FILES" | xargs markdownlint-cli2 --config .markdownlint.json 2>&1; then
                echo "::error::Markdown lint issues detected. Run 'markdownlint-cli2 --fix' to fix auto-fixable issues."
                exit 1
              else
                echo "✅ Markdown lint check passed"
              fi
            else
              # Run without config if no config file exists
              if ! echo "$MD_FILES" | xargs markdownlint-cli2 2>&1; then
                echo "::error::Markdown lint issues detected. Run 'markdownlint-cli2 --fix' to fix auto-fixable issues."
                exit 1
              else
                echo "✅ Markdown lint check passed"
              fi
            fi
          else
            echo "No markdown files found to check"
          fi
          echo "::endgroup::"
        continue-on-error: false

      - name: Run tests
        id: tests
        run: |
          echo "::group::Running test suite"
          # Run tests with coverage, capturing output for analysis
          if ! uv run python -m pytest tests/ -v --cov=src/cortex --cov-report=xml --cov-report=term --cov-fail-under=90; then
            echo "::error::Test suite failed. All tests must pass with at least 90% coverage."
            exit 1
          fi
          echo "✅ All tests passed with required coverage"
          echo "::endgroup::"

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml
          fail_ci_if_error: false
          token: ${{ secrets.CODECOV_TOKEN }}
        continue-on-error: true

      - name: Quality check summary
        if: always()
        run: |
          echo "=== Quality Check Summary ==="
          echo "Formatting: ${{ steps.formatting.outcome }}"
          echo "Formatting (Synapse): ${{ steps.formatting_synapse.outcome }}"
          echo "Linting: ${{ steps.linting.outcome }}"
          echo "Linting (Synapse): ${{ steps.linting_synapse.outcome }}"
          echo "Type Check (Source): ${{ steps.type_check_src.outcome }}"
          echo "Type Check (Tests/Scripts): ${{ steps.type_check_tests.outcome }}"
          echo "File Sizes: ${{ steps.file_sizes.outcome }}"
          echo "Function Lengths: ${{ steps.function_lengths.outcome }}"
          echo "Spelling: ${{ steps.spelling.outcome }}"
          echo "Markdown Lint: ${{ steps.markdown_lint.outcome }}"
          echo "Tests: ${{ steps.tests.outcome }}"
          echo "============================="
          
          # Fail if any critical check failed
          if [ "${{ steps.formatting.outcome }}" = "failure" ] || \
             [ "${{ steps.formatting_synapse.outcome }}" = "failure" ] || \
             [ "${{ steps.linting.outcome }}" = "failure" ] || \
             [ "${{ steps.linting_synapse.outcome }}" = "failure" ] || \
             [ "${{ steps.type_check_src.outcome }}" = "failure" ] || \
             [ "${{ steps.type_check_tests.outcome }}" = "failure" ] || \
             [ "${{ steps.file_sizes.outcome }}" = "failure" ] || \
             [ "${{ steps.function_lengths.outcome }}" = "failure" ] || \
             [ "${{ steps.spelling.outcome }}" = "failure" ] || \
             [ "${{ steps.markdown_lint.outcome }}" = "failure" ] || \
             [ "${{ steps.tests.outcome }}" = "failure" ]; then
            echo "::error::One or more quality checks failed. See above for details."
            exit 1
          fi
          
          echo "✅ All quality checks passed!"
